// 'number' + 3 + 3 -> number33 (конкатенація)
// null + 3 -> 3 (жодне значення не є рядком, тому це два числа, null стає 0)
// 5 && "qwerty" -> qwerty  (логічне І, повертає перше значення, якщо воно false, відповідно перше значення дає true, тому отримаємо друге)
// +'40' + +'2' + "hillel"; -> 42hillel (унарний плюс дає 40 + 2 = 42, далі конкатенація)
// '10' - 5 === 6; -> false (віднімання, потім порівняння, тобто 10 -5 = 5, і відповідно 5 дорівнює 6 це false)
// true + false -> 1 (+ приводить до чисел і відповідно 1 + 0)
// '4px' - 3 -> NaN (4px в число = NaN, і Nan -3 це Nan)
// '4' - 3 -> 1 (в числа, потім 4 -3 = 1)
// '6' + 3 ** 0; -> 61 (підноситься в степінь і потім конкатенація)
// 12 / '6' -> 2 (в число і потім ділення)
// '10' + (5 === 6); -> 10false (порівняння дає false, далі конкатенація)
// null == '' -> false (null дорівнює або undefined або собі при нестрогому порівнянні)
// 3 ** (9 / 3); -> 27 (в дужках = 3 і потім степінь)
// !!'false' == !!'true' -> true (!! в булевий тип, непорожній рядок це true, відповідно true == true, і як наслідок true)
// 0 || '0' && 1 -> 1 (спочатку логічне І дає 1, потім АБО шукає перше true значення, відповідно лишається 1)
// (+null == false) < 1; -> false (унарний + перетворює в 0, false це 0, відповідно 0 = 0, а це true, і далі true < 1, тобто 1 < 1, а це false)
// false && true || true -> true (спочатку I, це буде false, і потім АБО вертає true)
// false && (false || true); -> false (спочатку дужки і відповідно АБО, і далі перше значення)
// (+null == false) < 1 ** 5; -> false (степінь, потім 0 = 0, і 1<1)